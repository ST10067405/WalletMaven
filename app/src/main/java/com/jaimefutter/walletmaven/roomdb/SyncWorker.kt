package com.jaimefutter.walletmaven.roomdb

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.google.firebase.auth.FirebaseAuth
import com.jaimefutter.walletmaven.ApiResponse
import com.jaimefutter.walletmaven.CategoryEntity
import com.jaimefutter.walletmaven.ExpenseEntity
import com.jaimefutter.walletmaven.RetrofitClient
import com.jaimefutter.walletmaven.WalletMavenAPIService
import kotlinx.coroutines.*
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response

class SyncWorker(context: Context, params: WorkerParameters) : CoroutineWorker(context, params) {
    private lateinit var userID: String
    private var lastApiCallTimestamp: Long = 0L
    private val debounceTimeMillis = 500L

    override suspend fun doWork(): Result {
        val db = WalletMavenDatabase.getDatabase(applicationContext)
        val apiService = RetrofitClient.instance.create(WalletMavenAPIService::class.java)

        // Initialise UserID
        userID = FirebaseAuth.getInstance().currentUser?.uid ?: ""

        // Check if the database is empty
        val isDatabaseEmpty = withContext(Dispatchers.IO) {
            db.expenseDao().getAllExpenses().isEmpty() && db.categoryDao().getAllCategories().isEmpty()
        }

        if (db.expenseDao().getAllExpenses().isEmpty() && db.categoryDao().getAllCategories().isEmpty()) {
            // Fetch from API if database is empty
            fetchDataFromAPI(db, apiService)
        } else {
            // Sync unsynced data if the database is not empty
            syncUnsyncedData(db, apiService)
        }

        return Result.success()
    }

    private suspend fun fetchDataFromAPI(db: WalletMavenDatabase, apiService: WalletMavenAPIService) {
        val currentTimestamp = System.currentTimeMillis()
        if (currentTimestamp - lastApiCallTimestamp < debounceTimeMillis) {
            return // Skip if the last API call was too recent
        }
        lastApiCallTimestamp = currentTimestamp

        withContext(Dispatchers.IO) {
            try {
                // Fetch categories synchronously
                val categoryResponse = apiService.getCategories(userID).execute()
                if (categoryResponse.isSuccessful) {
                    categoryResponse.body()?.data?.let { categories ->
                        val existingCategories = db.categoryDao().getCategoriesByUser(userID)
                        val newCategories = categories.filter { apiCategory ->
                            // Only insert if the category does not already exist
                            existingCategories.none { it.name == apiCategory.name && it.userID == userID }
                        }
                        if (newCategories.isNotEmpty()) {
                            val categoryEntities = newCategories.map {
                                CategoryEntity(
                                    id = 0, // Auto-generated by Room
                                    name = it.name,
                                    budgetLimit = it.budgetLimit,
                                    userID = it.userID,
                                    isSynced = it.isSynced,
                                    documentId = it.documentId
                                )
                            }
                            db.categoryDao().insertAll(categoryEntities)
                        }
                    }
                }

                // Fetch expenses synchronously
                val expenseResponse = apiService.getExpenses(userID).execute()
                if (expenseResponse.isSuccessful) {
                    expenseResponse.body()?.data?.let { expenses ->
                        val existingExpenses = db.expenseDao().getExpensesByUser(userID)
                        val newExpenses = expenses.filter { apiExpense ->
                            // Only insert if the expense does not already exist
                            existingExpenses.none {
                                it.storeName == apiExpense.storeName &&
                                        it.price == apiExpense.price &&
                                        it.date == apiExpense.date &&
                                        it.userID == userID
                            }
                        }
                        if (newExpenses.isNotEmpty()) {
                            val expenseEntities = newExpenses.map {
                                ExpenseEntity(
                                    id = 0, // Auto-generated by Room
                                    storeName = it.storeName,
                                    price = it.price,
                                    category = it.category,
                                    date = it.date,
                                    userID = it.userID,
                                    imageUrl = it.imageUrl,
                                    isSynced = it.isSynced,
                                    documentId = it.documentId
                                )
                            }
                            db.expenseDao().insertAll(expenseEntities)
                        }
                    }
                }
            } catch (e: Exception) {
                // Handle the exception (e.g., log the error or retry mechanism)
            }
        }
    }

    private suspend fun syncUnsyncedData(db: WalletMavenDatabase, apiService: WalletMavenAPIService) {
        val syncSuccessful = mutableListOf<Boolean>()

        withContext(Dispatchers.IO) {
            val unsyncedExpenses = db.expenseDao().getUnsyncedExpenses(userID)
            val unsyncedCategories = db.categoryDao().getUnsyncedCategories(userID)

            if (unsyncedExpenses.isEmpty() && unsyncedCategories.isEmpty()) {
                return@withContext // Nothing to sync
            }

            // Sync expenses
            unsyncedExpenses.forEach { expense ->
                // Create a new expense object with isSynced set to true for the API
                val expenseToUpload = expense.copy(isSynced = true)
                val call = apiService.addExpense(expenseToUpload) // Ensure isSynced is true here
                call.enqueue(object : Callback<ApiResponse> {
                    override fun onResponse(call: Call<ApiResponse>, response: Response<ApiResponse>) {
                        CoroutineScope(Dispatchers.IO).launch {
                            if (response.isSuccessful) {
                                db.expenseDao().insertExpense(expense.copy(isSynced = true))
                                syncSuccessful.add(true)
                            } else {
                                syncSuccessful.add(false)
                            }
                        }
                    }

                    override fun onFailure(call: Call<ApiResponse>, t: Throwable) {
                        syncSuccessful.add(false)
                    }
                })
            }

            // Sync categories
            unsyncedCategories.forEach { category ->
                // Create a new category object with isSynced set to true for the API
                val categoryToUpload = category.copy(isSynced = true)
                val call = apiService.addCategory(categoryToUpload) // Ensure isSynced is true here
                call.enqueue(object : Callback<ApiResponse> {
                    override fun onResponse(call: Call<ApiResponse>, response: Response<ApiResponse>) {
                        CoroutineScope(Dispatchers.IO).launch {
                            if (response.isSuccessful) {
                                db.categoryDao().insertCategory(category.copy(isSynced = true))
                                syncSuccessful.add(true)
                            } else {
                                syncSuccessful.add(false)
                            }
                        }
                    }

                    override fun onFailure(call: Call<ApiResponse>, t: Throwable) {
                        syncSuccessful.add(false)
                    }
                })
            }

            // Wait for all sync operations to complete
            while (syncSuccessful.size < (unsyncedExpenses.size + unsyncedCategories.size)) {
                // Optionally add a delay to avoid busy waiting
                delay(100) // Add a small delay to prevent busy-waiting
            }
        }
    }
}